## 总体评价

这份设计文档质量很高，结构清晰，考虑周全。将研究功能拆分为"准备"和"分析"两个阶段的思路是正确的，既能优化资源利用，也符合用户心智模型。技术选型、数据库设计和实现阶段的划分都比较合理，为项目落地提供了坚实的基础。

然而，在状态转换的鲁棒性、数据库设计的可扩展性以及部分模块的复用风险上，存在一些关键问题需要解决。以下是具体的审核意见。

## 关键问题（必须修复）

1.  **L2→L1 状态恢复存在数据丢失风险**
    -   **问题描述**: 设计中提到从 L2 返回 L1 时，"从当前 GameState 提取 moves[] 恢复到 LiveBoard"。`GameState` 是后端引擎维护的最终盘面状态，它不包含用户在 L1（甚至 L2）进行的非落子编辑操作（如移动棋子、删除棋子）的原始序列。如果用户在 L2 编辑棋盘后返回 L1，将无法恢复到 L1 的原始 `moves` 序列，可能导致棋局与用户预期不符。
    -   **建议修复方案**:
        -   **方案 A (推荐)**: L1 的 `moves` 状态应该在 `ResearchPage` 组件中持久化。当从 L2 返回 L1 时，直接重用这个状态，而不是从 `GameState` 反向推算。L2 中的任何棋盘变更应被视为临时的，如需保存应通过"另存为"操作，而不是通过返回 L1 来同步。
        -   **方案 B (复杂)**: 在 L2 的每次编辑都生成一个新的 SGF 发送到后端，并更新 L1 的 `moves` 状态。这会增加复杂性和后端负载，不推荐。

2.  **复用 `useGameSession` Hook 存在兼容性问题**
    -   **问题描述**: `useGameSession` Hook 最初为"对弈"设计，其通信协议和后端逻辑主要处理线性的、轮流的落子。研究模块允许自由编辑（移动、删除），这些操作直接作为"play"事件发送给后端 `KaTrain` 对弈会话，可能会导致后端状态错乱或被拒绝。
    -   **建议修复方案**: 创建一个新的 `useResearchSession` hook，并为其在后端配备专门的 `research` 会话处理器。该处理器需要明确支持 `edit_board` 类型的指令，例如 `{"action": "set_stones", "add": ["Q16"], "remove": ["D4"]}`，而不是复用 `play` 指令。这能确保前后端对棋盘编辑的理解是一致的。

3.  **`user_games` 所有权模型导致数据冗余**
    -   **问题描述**: "人人对弈为双方各产生 1 条记录"的设计会导致同一份 SGF 内容被重复存储多次，浪费存储空间，也为数据同步带来麻烦。
    -   **建议修复方案**: 对数据库进行范式化。
        1.  创建一个核心的 `game_records` 表，用于存储唯一的 SGF 内容、对局信息（棋手、结果等）。
        2.  创建一个 `user_library_entries` 关联表，通过 `user_id` 和 `game_id` 将用户与棋谱记录关联起来，并可以添加 `role`（如 owner, player_black, shared_by）等元数据。这样一份棋谱只存一次，多个用户可以同时拥有对它的引用。

## 改进建议（推荐但非必须）

1.  **分析数据 API 的性能**
    -   **建议描述**: `/api/v1/user-games/{id}/analysis` 一次性返回整局分析数据，对于长对局（如 200+ 手）会造成巨大的网络负载和前端内存压力。
    -   **具体方案**:
        -   为该 API 增加分页参数，例如 `?start_move=0&limit=50`。
        -   长远来看，可以考虑在浏览分析时通过 WebSocket 按需请求每一步的分析数据，以获得最佳体验。

2.  **L1→L2 的 SGF 序列化健壮性**
    -   **建议描述**: 将 `moves[]` 数组手动拼接为 SGF 字符串时，容易忽略 SGF 标准的复杂性，例如连续同色落子 (`AB[...][...]`) 或让子/初始置き石 (`AB` / `AW` 节点)。
    -   **具体方案**: 在前端引入一个经过验证的 SGF 解析和生成库（如 `fflat-sgf`），确保从任意 `moves` 序列生成的 SGF 都是合规的。

3.  **`user_game_analysis` 与 `live_analysis` 的合并**
    -   **建议描述**: 设计稿已指出两表结构对齐，但将它们分开会造成长期的技术债务，后端需要维护两套相似的逻辑。
    -   **具体方案**: 建议在当前阶段就将它们合并为一张通用的 `game_analysis` 表。该表可以通过一个 `source_type` (e.g., 'user_game', 'live_game') 和 `source_id` 字段，实现与不同棋谱来源的多态关联。

4.  **工具栏 UI/UX 优化**
    -   **建议描述**: L1 和 L2 共用完全相同的工具栏布局，仅通过置灰部分按钮来区分，可能无法为用户提供最佳的操作引导。
    -   **具体方案**: 可以在共用 `ResearchToolbar` 组件的基础上，根据 `isAnalyzing` 状态动态调整按钮的分组和排序。例如，在 L1 突出"打开/保存"等文件操作，在 L2 将"显示推荐/领地"等分析开关组合在一起并置于更显眼的位置。

## 遗漏补充

1.  **错误处理与边界情况**
    -   **遗漏点**: 设计中缺少对异常流程的详细说明。
    -   **补充建议**:
        -   **SGF 无效**: L1 传到 L2 的 SGF 如果格式错误，后端应能正确处理并向前端返回明确的错误信息。
        -   **网络中断**: L2 分析过程中 WebSocket 断线，UI 应有明显的"已断开"状态提示和重连机制。
        -   **权限控制**: API 设计部分需要明确，所有对 `/api/v1/user-games` 的操作都必须在后端进行严格的权限校验，确保用户只能操作自己的棋谱。

2.  **深度链接（Deep Linking）**
    -   **遗漏点**: 未考虑如何通过 URL 直接进入 L2 分析模式。
    -   **补充建议**: 应支持类似 `/galaxy/research?game_id=...&analyze=true` 的 URL。`ResearchPage` 在初始化时需检查 URL 参数，如果存在 `game_id`，则直接获取棋谱数据；如果 `analyze=true`，则跳过 L1，直接进入 L2 分析流程。

3.  **`LiveBoard` 客户端性能**
    -   **遗漏点**: 客户端 `buildBoardState()` 的性能在复杂对局下可能成为瓶颈。
    -   **补充建议**: 需要确保棋盘状态计算是增量式的，即应用一个新着法时是在前一状态基础上计算，而不是每次都从头开始。对于复杂的打劫局面，需要进行压力测试。

## Phase 优化建议

当前阶段划分是可行的，但为了更快地交付核心价值，可以考虑以下调整：

-   **定义最小可用产品 (MVP)**:
    -   **核心功能**: Phase 1, 2, 3, 4, 5。这构成了"本地摆棋 → 启动分析"的核心循环。
    -   **简化**: Phase 6（棋谱库）可以先只实现"从本地 SGF 打开"和"下载到本地"，将"保存到云端/从云端加载"的功能推迟。Phase 8（分析持久化）可以推迟，MVP 版本的分析可以是会话级别的，关闭即丢失。
    -   **解耦**: Phase 7（对弈模块联动）与其他功能耦合度低，可以完全独立，在 MVP 之后实施。

-   **并行开发建议**:
    -   **Track 1 (后端)**: `Phase 1` (数据库) + `Phase 2` (API) 可以并行。
    -   **Track 2 (前端)**: `Phase 3` (L1 页面) 可以与后端并行，通过 Mock API 进行开发。
    -   当前后端 API 定义完成后，前端即可开始 `Phase 4, 5, 6` 的开发。

通过这种方式，可以最大化并行效率，并优先上线一个虽功能有限但流程完整的 MVP 版本。
